\documentclass{livret}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb]{babel}
\usepackage{libertine}
\usepackage[pdftex]{graphicx}
\usepackage{eurosym}
\usepackage{amsmath}
\usepackage{SIunits}


\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}
		\includegraphics[width=200pt]{cpe.jpg}

    \textsc{\Large Rapport de projet d'électronique}\\[1.5cm]

    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries Centrale inertielle\\[0.4cm] }

    \HRule \\[2cm]

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
        MOUGIN \textsc{Paul}\\
        RATTRAPAGE DE 4ETI 2013\\
      \end{flushleft}
    \end{minipage}

    \vfill

    % Bottom of the page
    {\large Juin 2015}

  \end{center}
  \end{sffamily}
\end{titlepage}

\tableofcontents

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}
	Le but de ce projet est de créer à l'aide d'une carte électronique STM32F3 Discovery une centrale inertielle en utilisant les accéléromètres et les gyroscopes embarqués dans la carte.
	
	\paragraph{}
	Tous les calculs doivent être effectué par le microprocesseur STM32 sur la carte embarquée. Les informations de positions calculées seront alors envoyer à un terminal via une liaison série.
	
\chapter{Études préalables}
	\section{Quid d'une centrale inertielle ?}
	\paragraph{}
	\begin{quote}
\emph{	Une centrale à inertie ou centrale inertielle est un instrument utilisé en navigation, capable d'intégrer les mouvements d'un mobile (accélération et vitesse angulaire) pour estimer son orientation (angles de roulis, de tangage et de cap), sa vitesse linéaire et sa position. L'estimation de position est relative au point de départ ou au dernier point de recalage.}\footnote{définition de Wikipedia} \end{quote}
	
	\paragraph{}
	En effet, une centrale inertielle est un appareil de mesure permettant de connaître la position de l'objet sur lequel elle est fixée sans avoir besoin d'informations extérieures. La seule connaissance de l'accélération linéaire selon trois axes ainsi que les vitesses angulaires autours de ces trois même axes permet de calculer la position relative de l'objet par rapport à sont point de départ.
	
	\paragraph{}
	Cet instrument de mesure est encore utilisé dans tous les avions de ligne pour compenser l'imprécision des systèmes satellitaires comme le GPS.
	
	\paragraph{}
	La précision d'une centrale inertielle varie en fonction de la précision des capteurs (accéléromètres et gyroscopes) utilisés mais aussi en fonction de algorithme de calcul utilisé pour traiter les données.
	
	\section{Considérations théoriques}
	\subsection*{Calcul de la position}
	\paragraph{}
	Les capteurs nous remontent une accélération linéaire ainsi qu'une vitesse angulaire suivant les trois axes (que nous appellerons X, Y et Z) de la centrale inertielle.\\
	Pour déterminer la position, le processeur doit déjà effectuer une intégration de l'accélération pour déterminer les vitesses linéaires par rapport au sol :
	\begin{equation}\vec{V}=\int{\vec{\gamma}dt}\end{equation}
	Puis pour déterminer la position, il doit encore intégrer la vitesse en prenant en compte la position de départ $ x_{0} $ :
	\begin{equation}x=\int{\vec{V}dt}+x_0\end{equation}
	
	Il existe plusieurs algorithmes permettant de calculer les intégrales succéssives; méthodes plus ou moins complexes et plus ou moins précises qui seront explorées dans la partie \emph{Calcul de l'intégration}.
	\paragraph{}
	Ces trois positions (une suivant chaque axe de la centrale) sont calculé par rapport au repère de la centrale et non le repère terrestre supposé galiléen. Or nous souhaitons connaître la position de l'objet dans un référentiel absolu.\\
	Pour cela il nous faut faire un changement de base, mais avant tout, connaître l'orientation de la centrale inertielle dans le repère de base.
	
	\subsection*{Calcul de l'orientation}
	\paragraph{}
		Pour connaître l'orientation de la centrale il nous faut connaître les angles de roulis, de tangage et de lacet (roll, pitch et heading en anglais) représentés sur la figure suivante :
	
	\newpage
	
	\begin{figure}
	\centering
		\includegraphics[scale=0.7]{RollPitchHeading.png}
	\caption{Angles de roulis, tangage et lacet}
	\end{figure}
	
		L'angle de roulis et de tangage sont calculables grâce aux composantes du vecteur accélération mesurées par accéléromètre de la carte notée $G_{Acc}=(G_{x}, G_{y}, G_{z})$ :
	\begin{equation}Roll=\arctan\left(\frac{-G_x}{Gz}\right)\end{equation}
	\begin{equation}Pitch=\arctan\left(\frac{G_y}{\sqrt{G_x^2+G_z^2}}\right)\end{equation}
	
	\paragraph{}
	L'angle de roulis (Roll) a une amplitude de $[-180; 180]$ et l'angle de tangage (Pitch) a une amplitude de $[-90; 90]$. Il n'est pas possible d'obtenir une amplitude de $360\degree$ sur les deux angles, il a donc été décidé de limiter l'angle de tangage sur une plage de $180\degree$.\\
	Ces deux formules sont tirées de la théorie des angles d'Euler. La démonstration de ces formules est détaillée dans la documentation \emph{Tilt Sensing Using a Three-Axis Accelerometer} de \textsc{Freescale Semiconductor} dont la référence se trouve en \textsc{Annexe}.
	
	\paragraph{}
	Pour calculer l'angle de lacet, il est nécessaire d'utiliser le magnétomètre de la carte car l'accéléromètre  seul ne nous permet pas d'aller plus loin. Nous récupérons les données du magnétomètre dans un vecteur $M = (M_x, M_y, M_z)$ ce qui nous permet de calculer les \emph{"`angles d'inclinaisons"'} aussi appelés \emph{tilted angles} :
	\begin{equation}x_{tilted}=M_x\cos(Pitch) + M_z\sin(Pitch)\end{equation}
	\begin{equation}y_{tilted}=M_x\sin(Roll)\sin(Pitch) + M_y\cos(Roll) - M_z\sin(Roll)\cos(Pitch)\end{equation}
	
	Ces \emph{tilted angles} nous permettent ensuite de calculer l'angle de lacet (Heading) :
	\begin{equation}Heading=\arctan\left(\frac{y_{tilted}}{x_{tilted}}\right)\end{equation}
	
	\subsection*{Calcul du changement de base}
	Une fois l'orientation de la centrale par rapport au sol connue, il est possible de calculer le vecteur accélération, vitesse ou position de la centrale inertielle dans le repère absolu grâce à la théorie des \emph{angles d'Euler} :
	
	\paragraph{} Connaissant les angles $\theta$, $\phi$, $\psi$ respectivement autour de x, y et z on peut calculer la matrice de rotation $R$ :

	\begin{equation}R=
\begin{pmatrix}
   1 & 0 & 0 \\
   0 & \cos\theta & -\sin\theta \\
   0 & \sin\theta & \cos\theta 
\end{pmatrix}
	\cdot
\begin{pmatrix}
   \cos\phi & 0 & \sin\phi \\
   0 & 1 & 0 \\
   -\sin\phi & 0 & \cos\phi 
\end{pmatrix}
	\cdot
\begin{pmatrix}
   \cos\psi & -\sin\psi & 0 \\
   \sin\psi & \cos\psi & 0 \\
   0 & 0 & 1 
\end{pmatrix}
		\end{equation}
		
		Ce qui donne la forme général suivante :
		\begin{equation}
		R=
		\begin{pmatrix}
		\cos\psi\cos\phi & -\sin\psi\cos\theta+\cos\psi\sin\phi\sin\theta & \sin\psi\sin\theta+\cos\psi\sin\phi\cos\theta \\
		\sin\psi\cos\phi & \cos\psi\cos\theta+\sin\psi\sin\phi\sin\theta & -\cos\psi\sin\theta+\sin\psi\sin\phi\cos\theta \\
		-\sin\phi & \cos\phi\sin\theta & \cos\phi\cos\theta
		\end{pmatrix}
		\end{equation}
		
		Ce qui permet ensuite, connaissant le vecteur position $POS$ $\begin{pmatrix}X\\Y\\Z\end{pmatrix}$ dans le repère de la centrale de calculer le vecteur position $POS'$ $\begin{pmatrix}X'\\Y'\\Z'\end{pmatrix}$ dans le repère absolu :
		
		\begin{equation}
		POS' = R \cdot POS
		\end{equation}
		
		\subsection*{Calcul de l'intégration}
		\paragraph{}
		comme dit plus haut, il existe plusieurs méthodes de calcul des intégrales certaines plus complexes et plus précises que d'autres. Nous allons en exposer deux :
		\subsubsection*{La méthode d'Euler}
		\paragraph{}
		La méthode d'Euler est une méthode numérique élémentaire de résolution d'équation différentielles du premier ordre. Elle consiste sur un intervalle de temps le plus court possible d'approximer une courbe grâce à ça dérivée.
		\paragraph{}
		On sait par la théorie de la dérivation que pour n'importe quelle fonction $f(x)$ dont la primitive est $F(x)$ sur un intervalle défini on a :
		\begin{equation}\lim_{h \to 0}\frac{F(x+h)-F(x)}{h}=f(x)\end{equation}
		
		aussi par conséquent si $h$ est très petit il est possible de calculer la Primitive de $f(x)$ par récurrence :
		\begin{equation}F(x+h)\approx F(x) + f(x)h\end{equation}
		
		Cette méthode très simpliste permet d'approximer l'intégration de manière assez grossière. L'erreur de cette méthode est d'ordre 2 soit $o(h^2)$ ce qui est assez élevé. Cette erreur est d'autant plus élevé lorsque l'on pratique cette méthode deux fois à la suite comme c'est le cas pour la centrale inertielle.
		
		\subsubsection*{Méthode de Simpson}
		\paragraph{}
		La méthode de Simpson utilise une approximation d'ordre 2 de $f$ grâce au polynôme quadratique $P$. Le polynôme représente une parabole entre $a$ et $b$ qui prend les même valeurs que $f$ aux points $a$, $b$ et $m=\frac{(a+b)}{2}$. On connait alors l'expression de cette parabole grâce à l'interpolation de Lagrange:
		\begin{equation}P(x)=f(a)\frac{x-m)(x-b)}{(a-m)(a-b)} + f(m)\frac{(x-a)x-b)}{(m-a)(m-b)} + f(b)\frac{(x-a)(x-m)}{(b-a)(b-m)}\end{equation}
		Le polynôme étant plus facile a intégrer on peut ainsi approximer l'intégrale de $f$ sur l'intervalle $[a, b]$ :
		\begin{equation}\int_a^b{f(x)dx}\approx \int_a^b{P(x)dx} = \frac{b-a}{6}\left[f(a)+4f(\frac{a+b}{2}+f(b)\right]\end{equation}
		
		Ainsi il est possible d'approximer l'intégrale de l'accélération pour en déduire la vitesse, en rendant l'intervalle $[a, b]$ le plus petit possible et en effectuant la somme successive des approximations.
	\paragraph{}
	Une méthode plus précise que la méthode d'Euler puisque sont erreur est d'ordre 4 soit $o(h^4)$ ce qui, concaténé à elle même laisse une erreur d'ordre 2, ce qui peut être suffisant pour notre centrale.
		


\chapter{Réalisation du projet}
	\section{Matériel mis à disposition}
	\paragraph{}
	Pour la réalisation de cette centrale inertielle, le seul élément imposé était la carte de développement: une \emph{STM32F3-Discovery} de chez \textsc{STMicroelectronics}
	
	\begin{figure}[h]
	\centering
		\includegraphics[scale=0.3]{stm32f3discovery.jpg}
	\caption{Carte \emph{STM32F3-Discovery} de \textsc{STMicroelectronics}}
	\end{figure}
	
	\paragraph{}
	Cette carte d'évaluation est équipée d'un microprocesseur ARM Cortex-M4, 256 KB de mémoire Flash et 46 KB de mémoire RAM. La carte embarque un accéléromètre LSM303DLHC trois axes et un gyroscope L3GD20 trois axes. La carte est également équipée de LED de différente couleurs ainsi que de deux boutons poussoirs.
	
	\paragraph{}
	Au niveau de la communication extérieur, la carte est équipée de deux port mini-USB. L'un, le ST-LINK/V2 permet de programmer et de débugger la carte à travers un logiciel dédié (nous utiliserons \emph{Keil \micro Vision5} pour cela).\\
	L'autre permet d'établir une communication avec d'autres éléments. nous l'utiliserons pour établir une liaison série entre la carte et un hyperterminal (\emph{Termite}) ou notre interface utilisateur développé en \emph{Qt}.

	\section{Implémentation sur la carte STM32F3}
	\paragraph{}
	Les travaux réalisés sur la carte sont divisés en plusieurs points indépendants: la récupération des données des capteurs, leur traitement et la communication via la liaison série USB.\\
	Le projet est à la base le projet de démonstration fournit par \textsc{STMicroelectronics} auquel on été retirés les exemples et fonctionnalité qui ne nous intéressaient pas et auquel ont été rajoutées des librairies permettant de réaliser certaines briques du programme.
	
	\subsection{Récupération des données des capteurs}
	\paragraph{}
	La première chose à faire avant de vouloir traiter une information est de la mesurer via un capteur puis de la récupérer pour l'utiliser plus tard dans les calculs.
	
	\paragraph{}
	Les fonctions utilisées pour récupérer les données des capteurs sont déjà implémentées dans les exemples par \textsc{STMicroelectronics}. Nous utilisons ainsi \emph{Demo\_CompassConfig(void)} pour initialiser le capteur LSM303DLHC puis les fonctions \emph{Demo\_CompassReadAcc(float* pfData)} et \emph{Demo\_CompassReadMag (float pfData)} pour récupérer les données de l'accéléromètre et du magnétomètre.
	
	\subsubsection*{Demo\_CompassConfig(void)}
	C'est la fonction qui est appelée pendant l'initialisation du programme et qui permet de configurer correctement les différents capteurs utilisés plus tard dans le programme.\\
	Les paramètres peuvent allez du mode d'alimentation à l'échelle utiliser tout en passant par la configuration des filtres utilisés pour traiter les signaux des capteurs.
	
	\subsubsection*{Demo\_CompassReadAcc(float* pfData) \& Demo\_CompassReadMag (float* pfData)}
	Ce sont deux fonctions permettent de récupérer les informations des capteurs et de les stocker dans un pointer mis en paramètre. Ces fonctions permettent aussi la calibration des données en fonction du mode choisi à l'initialisation.

  \subsection{Traitements des données}
	
	\paragraph{}
	Une fois les données récupérer depuis les capteurs ils faut les traiter afin de calculer ce que nous cherchons: l'orientation de la centrale inertielle grâce à ses angles de roulis, de tangage et de lacet ainsi que sa position relative par rapport au référentiel terrestre.
	
	\subsubsection*{ReadOrientation(float *pHeading, float *pRoll, float *pPitch)} 
	C'est la fonction qui permet de retourner dans les pointeurs en paramètres les angles d'orientation en effectuant les calculs détaillés dans la partie théorique :
	
	\begin{figure}[h]
	\centering
		\includegraphics[scale=0.7]{readOrientation}
	\caption{Fonction void ReadOrientation(float *pHeading, float *pRoll, float *pPitch)}
	\end{figure}
	
	\subsubsection*{EulerMethode(float *pX, float *pY, float *pZ)}
	C'est la fonction qui permet de retourner dans les pointeurs en paramètre les positions relatives de la carte en utilisant la méthode d'Euler.\\
	Cette méthode n'a pas encore été implémentée.
	
	\subsubsection*{SimpsonMethode(float *pX, float *pY, float *pZ)}
	C'est la fonction qui permet de retourner dans les pointeurs en paramètre les positions relatives de la carte en utilisant la méthode de Simpson.\\
	Cette méthode n'a pas encore été implémentée.
	
	\subsection{Communication série}
	Une fois toutes les données calculées, il faut les afficher à l'utilisateur. La carte ne déposant d'aucun affichage intégré, mis à part ses LED, ce qui rend l'affichage pas vraiment évident, il faut communiquer ces données à un autre appareil - comme un PC - qui pourra les afficher.
	
	\paragraph{}
	Avant de parler d'une quelconque interface Homme-Machine, il est donc important de transmettre correctement ces données via une liaison série de type Virtual COM entre le port USB-USER de la carte et un port USB d'un ordinateur.\\
	La librairie permettant d'envoyer et de recevoir des message à travers une liaison série est aussi une librairie créée et mise à disposition par \textsc{STMicroelectronics} dans son projet de démonstration. \\
	
	\paragraph{}
	En connectant le port USB-USER de la carte à un PC, ce dernier doit installer le bon périphérique et ainsi reconnaître un port de communication VCP. Pour ce connecter à ce port, il faut que la liaison soit effective entre la carte et le PC, que la liaison soit initialisé du côté de la carte et que du côté du PC, on se connecte au port de communication alloué avec les bons paramètres, à savoir :
	\begin{itemize}
	\item BaudRate : 115200
	\item Bits de donnée : 8
	\item Parité : Non
	\item Bit de stop : 1
	\item Contrôle de flux : Non
	\end{itemize}
	
	\paragraph{} Une fois la connexion établie entre les deux entités, on peut envoyer à travers la liaison série grâce à la fonction \emph{VCP\_PutStr(char* buffer)} où le buffer est une chaine de caractères contenant le message que l'on souhaite envoyer. \\
	Dans notre cas, le protocole est le suivant : \emph{"$X: \%11.3f$   $Y: \%11.3f$   $Z: \%11.3f\backslash n$"} où \emph{\%11.3f} est un nombre flottant avec 3 chiffres avant et après la virgule. Ce protocole permet l'affichage des informations directement dans un hyper terminal comme \emph{Termite} mais aussi la concaténation des informations par un autre logiciel connaissant ce protocole, comme c'est le cas pour l'interface utilisateur.
	
	\section{Interface utilisateur}
	\paragraph{}
	
\chapter{Améliorations possibles}
	\section{Gestion des accéléromètres}
	\paragraph{}
	
	\section{Fiabilité}
	\paragraph{}
		
\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\paragraph{}
	
\end{document}