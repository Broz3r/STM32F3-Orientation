\documentclass{livret}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb]{babel}
\usepackage{libertine}
\usepackage[pdftex]{graphicx}
\usepackage{eurosym}
\usepackage{amsmath}
\usepackage{SIunits}


\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{titlepage}
  \begin{sffamily}
  \begin{center}
		\includegraphics[width=200pt]{cpe.jpg}

    \textsc{\Large Rapport de projet d'électronique}\\[1.5cm]

    % Title
    \HRule \\[0.4cm]
    { \huge \bfseries Centrale inertielle\\[0.4cm] }

    \HRule \\[2cm]

    % Author and supervisor
    \begin{minipage}{0.4\textwidth}
      \begin{flushleft} \large
        MOUGIN \textsc{Paul}\\
        RATTRAPAGE DE 4ETI 2013\\
      \end{flushleft}
    \end{minipage}

    \vfill

    % Bottom of the page
    {\large Juin 2015}

  \end{center}
  \end{sffamily}
\end{titlepage}

\tableofcontents

\chapter*{Introduction}
\addcontentsline{toc}{chapter}{Introduction}
	Le but de ce projet est de créer à l'aide d'une carte électronique STM32F3 Discovery une centrale inertielle en utilisant les accéléromètres et les gyroscopes embarqués dans la carte.
	
	\paragraph{}
	Tous les calculs doivent être effectués par le microcontrôleur STM32 sur la carte embarquée. Les informations de positions calculées seront alors envoyer à un terminal via une liaison série.
	
\chapter{Études préalables}
	\section{Quid d'une centrale inertielle ?}
	\paragraph{}
	\begin{quote}
\emph{	Une centrale à inertie ou centrale inertielle est un instrument utilisé en navigation, capable d'intégrer les mouvements d'un mobile (accélération et vitesse angulaire) pour estimer son orientation (angles de roulis, de tangage et de cap), sa vitesse linéaire et sa position. L'estimation de position est relative au point de départ ou au dernier point de recalage.}\footnote{définition de Wikipedia} \end{quote}
	
	\paragraph{}
	En effet, une centrale inertielle est un appareil de mesure permettant de connaître la position de l'objet sur lequel elle est fixée sans avoir besoin d'informations extérieures. La seule connaissance de l'accélération linéaire selon trois axes ainsi que les vitesses angulaires autours de ces trois mêmes axes permet de calculer la position relative de l'objet par rapport à son point de départ.
	
	\paragraph{}
	Cet instrument de mesure est encore utilisé dans tous les avions de ligne pour compenser l'imprécision des systèmes satellitaires comme le GPS.
	
	\paragraph{}
	La précision d'une centrale inertielle varie en fonction de la précision des capteurs (accéléromètres et gyroscopes) utilisés mais aussi en fonction de l'algorithme de calcul utilisé pour traiter les données.
	
	\section{Considérations théoriques}
	\subsection*{Calcul de la position}
	\paragraph{}
	Les capteurs nous remontent une accélération linéaire ainsi qu'une vitesse angulaire suivant les trois axes (que nous appellerons X, Y et Z) de la centrale inertielle.\\
	Pour déterminer la position, le processeur doit déjà effectuer une intégration de l'accélération pour déterminer les vitesses linéaires :
	\begin{equation}\vec{V}=\int{\vec{\gamma}dt}\end{equation}
	Puis pour déterminer la position, il doit encore intégrer la vitesse en prenant en compte la position de départ $ x_{0} $ :
	\begin{equation}x=\int{\vec{V}dt}+x_0\end{equation}
	
	Il existe plusieurs algorithmes permettant de calculer les intégrales successives; algorithmes plus ou moins complexes et plus ou moins précis qui seront exposés dans la partie \emph{Calcul de l'intégration}.
	\paragraph{}
	Ces trois positions (une suivant chaque axe de la centrale) sont calculées par rapport au repère de la centrale et non le repère terrestre supposé galiléen. Or nous souhaitons connaître la position de l'objet dans un référentiel absolu.\\
	Pour cela il faut effectuer un changement de base, mais avant tout, connaître l'orientation de la centrale inertielle par rapport au sol.
	
	\subsection*{Calcul de l'orientation}
	\paragraph{}
		Pour connaître l'orientation de la centrale nous avons besoin de connaître les angles de roulis, de tangage et de lacet (roll, pitch et heading - ou yaw - en anglais) représentés sur la figure suivante :
	
	\newpage
	
	\begin{figure}
	\centering
		\includegraphics[scale=0.7]{RollPitchHeading.png}
	\caption{Angles de roulis, tangage et lacet}
	\end{figure}
	
		Les angles de roulis et de tangage sont calculables grâce aux composantes du vecteur accélération mesurées par l'accéléromètre de la carte. Nous les noterons $G_{Acc}=(G_{x}, G_{y}, G_{z})$ :
	\begin{equation}Roll=\arctan\left(\frac{G_y}{G_z}\right)\end{equation}
	\begin{equation}Pitch=-\arctan\left(\frac{G_x}{\sqrt{G_y^2+G_z^2}}\right)\end{equation}
	
	\paragraph{}
	L'angle de roulis ($Roll$) a une amplitude de $[-180; 180]$ et l'angle de tangage ($Pitch$) a une amplitude de $[-90; 90]$. Il n'est pas possible d'obtenir une amplitude de $360\degree$ sur les deux angles en même temps, il a donc été décidé de limiter l'angle de tangage sur une plage de $180\degree$.\\
	Ces deux formules sont tirées de la théorie des angles d'Euler. La démonstration de ces formules est détaillée dans la documentation \emph{Tilt Sensing Using a Three-Axis Accelerometer} de \textsc{Freescale Semiconductor} dont la référence se trouve en \textsc{Annexe}.
	
	\paragraph{}
	Pour calculer l'angle de lacet, il est nécessaire d'utiliser le magnétomètre de la carte car l'accéléromètre seul ne nous permet pas d'aller plus loin. Nous récupérons les données du magnétomètre dans un vecteur $M = (M_x, M_y, M_z)$ ce qui nous permet de calculer les \emph{"`angles d'inclinaisons"'} aussi appelés \emph{tilted angles} :
	\begin{equation}x_{tilted}=M_x\cos(Pitch) + M_z\sin(Pitch)\end{equation}
	\begin{equation}y_{tilted}=M_x\sin(Roll)\sin(Pitch) + M_y\cos(Roll) - M_z\sin(Roll)\cos(Pitch)\end{equation}
	
	Ces \emph{tilted angles} nous permettent ensuite de calculer l'angle de lacet (Heading) :
	\begin{equation}Heading=\arctan\left(\frac{y_{tilted}}{x_{tilted}}\right)\end{equation}
	
	Une autre méthode permet aussi de calculer les angles de notre carte. Il s'agit d'utiliser les mesures du gyroscope qui nous donne la valeur de la vitesse angulaire suivant les trois axes de notre carte. Comme pour la position linéaire de la carte, nous pouvons calculer la position angulaire ($\alpha$)en intégrant la vitesse angulaire ($\vec{\omega}$) :
	
	\begin{equation}\alpha=\int{\vec{\omega}dt}+\alpha_0\end{equation}
	
	\subsection*{Calcul du changement de base}
	Une fois l'orientation de la centrale par rapport au sol connue, il est possible de calculer les vecteurs accélération, vitesse et position de la centrale inertielle dans le repère absolu grâce à la théorie des \emph{angles d'Euler} :
	
	\paragraph{} Connaissant les angles $\theta$, $\phi$, $\psi$ respectivement autour de x, y et z, il est possible de calculer la matrice de rotation $R$ :

	\begin{equation}R=
\begin{pmatrix}
   1 & 0 & 0 \\
   0 & \cos\theta & -\sin\theta \\
   0 & \sin\theta & \cos\theta 
\end{pmatrix}
	\cdot
\begin{pmatrix}
   \cos\phi & 0 & \sin\phi \\
   0 & 1 & 0 \\
   -\sin\phi & 0 & \cos\phi 
\end{pmatrix}
	\cdot
\begin{pmatrix}
   \cos\psi & -\sin\psi & 0 \\
   \sin\psi & \cos\psi & 0 \\
   0 & 0 & 1 
\end{pmatrix}
		\end{equation}
		
		Ce qui donne la forme général suivante :
		\begin{equation}
		R=
		\begin{pmatrix}
		\cos\psi\cos\phi & -\sin\psi\cos\theta+\cos\psi\sin\phi\sin\theta & \sin\psi\sin\theta+\cos\psi\sin\phi\cos\theta \\
		\sin\psi\cos\phi & \cos\psi\cos\theta+\sin\psi\sin\phi\sin\theta & -\cos\psi\sin\theta+\sin\psi\sin\phi\cos\theta \\
		-\sin\phi & \cos\phi\sin\theta & \cos\phi\cos\theta
		\end{pmatrix}
		\end{equation}
		
		Ce qui permet ensuite, connaissant le vecteur position $POS$ $\begin{pmatrix}X\\Y\\Z\end{pmatrix}$ dans le repère de la centrale de calculer le vecteur position $POS'$ $\begin{pmatrix}X'\\Y'\\Z'\end{pmatrix}$ dans le repère absolu :
		
		\begin{equation}
		POS' = POS \cdot R
		\end{equation}
		
		\subsection*{Calcul de l'intégration}
		\paragraph{}
		Comme dit précédemment, il existe plusieurs méthodes de calcul des intégrales, certaines plus complexes et plus précises que d'autres. Nous allons en exposer deux :
		\subsubsection*{La méthode d'Euler}
		\paragraph{}
		La méthode d'Euler est une méthode numérique élémentaire de résolution d'équations différentielles du premier ordre. Elle consiste sur un intervalle de temps le plus court possible d'approximer une courbe grâce à ça dérivée.
		\paragraph{}
		Nous savons par la théorie de la dérivation que pour n'importe quelle fonction $f(x)$ dont la primitive est $F(x)$ sur un intervalle défini :
		\begin{equation}\lim_{h \to 0}\frac{F(x+h)-F(x)}{h}=f(x)\end{equation}
		
		Aussi, par conséquent, si $h$ est très petit, il est possible de calculer la primitive de $f(x)$ par récurrence :
		\begin{equation}F(x+h)\approx F(x) + f(x)h\end{equation}
		
		Cette méthode très simpliste permet d'approximer l'intégration de manière assez grossière. L'erreur de cette méthode est d'ordre 2 soit $o(h^2)$ ce qui est assez élevé. Cette erreur est d'autant plus élevée lorsque cette méthode est appliquée deux fois à la suite comme c'est le cas pour le calcul de la position depuis l'accélération.
		
		\subsubsection*{Méthode de Simpson}
		\paragraph{}
		La méthode de Simpson utilise une approximation d'ordre 2 de $f$ grâce au polynôme quadratique $P$. Le polynôme représente une parabole entre $a$ et $b$ qui prend les même valeurs que $f$ aux points $a$, $b$ et $m=\frac{(a+b)}{2}$. On connaît alors l'expression de cette parabole grâce à l'interpolation de Lagrange:
		\begin{equation}P(x)=f(a)\frac{(x-m)(x-b)}{(a-m)(a-b)} + f(m)\frac{(x-a)x-b)}{(m-a)(m-b)} + f(b)\frac{(x-a)(x-m)}{(b-a)(b-m)}\end{equation}
		
		Un polynôme étant plus facile à intégrer nous pouvons ainsi approximer l'intégrale de $f$ sur l'intervalle $[a, b]$ :
		\begin{equation}\int_a^b{f(x)dx}\approx \int_a^b{P(x)dx} = \frac{b-a}{6}\left[f(a)+4f\left(\frac{a+b}{2}\right)+f(b)\right]\end{equation}
		
		Ainsi il est possible d'approximer l'intégrale de l'accélération pour en déduire la vitesse, en rendant l'intervalle $[a, b]$ le plus petit possible et en effectuant la somme successive de ces approximations.
	\paragraph{}
	Une méthode plus précise que la méthode d'Euler puisque sont erreur est d'ordre 4 soit $o(h^4)$ ce qui, concaténée à elle même laisse une erreur d'ordre 2, ce qui peut être suffisant pour notre centrale.
		


\chapter{Réalisation du projet}
	\section{Matériel mis à disposition}
	\paragraph{}
	Pour la réalisation de cette centrale inertielle, le seul élément imposé était la carte de développement: une \emph{STM32F3-Discovery} de chez \textsc{STMicroelectronics}
	
	\begin{figure}[h]
	\centering
		\includegraphics[scale=0.3]{stm32f3discovery.jpg}
	\caption{Carte \emph{STM32F3-Discovery} de \textsc{STMicroelectronics}}
	\end{figure}
	
	\paragraph{}
	Cette carte d'évaluation est équipée d'un microprocesseur ARM Cortex-M4, 256 KB de mémoire Flash et 46 KB de mémoire RAM. La carte embarque un accéléromètre LSM303DLHC trois axes et un gyroscope L3GD20 trois axes. La carte est également équipée de LED de différentes couleurs ainsi que de deux boutons poussoirs (USER et RESET).
	
	\paragraph{}
	Au niveau de la communication extérieure, la carte est équipée de deux port mini-USB. L'un, le ST-LINK/V2 permet de programmer et de débugger la carte à travers un logiciel dédié (nous utiliserons \emph{Keil \micro Vision5} pour cela).\\
	L'autre permet d'établir une communication avec d'autres éléments que nous utiliserons pour établir une liaison série entre la carte et un hyper terminal (\emph{Termite}) ou notre interface utilisateur développée en \emph{Qt}.

	\section{Implémentation sur la carte STM32F3}
	\paragraph{}
	Les travaux réalisés sur la carte sont divisés en plusieurs points indépendants: la récupération des données des capteurs, leur traitement et la communication via la liaison série USB.\\
	Le projet est à la base le projet de démonstration fournit par \textsc{STMicroelectronics} auquel ont été retirés les exemples et fonctionnalités qui ne nous intéressaient pas et auquel ont été rajoutées des librairies permettant de réaliser certaines briques du programme comme la librairie VCOM.
	
	\subsection{Récupération des données des capteurs}
	\paragraph{}
	La première chose à faire avant de vouloir traiter une information est de la mesurer via un capteur puis de la récupérer pour l'utiliser plus tard dans les calculs.
	
	\paragraph{}
	Les fonctions utilisées pour récupérer les données des capteurs sont déjà implémentées dans les exemples par \textsc{STMicroelectronics}. Nous utilisons ainsi \emph{InitAccAndMag(void)} pour initialiser le capteur LSM303DLHC puis les fonctions \emph{ReadAccelerometer(float* pfData)} et \emph{ReadMagnetometer(float pfData)} pour récupérer les données de l'accéléromètre et du magnétomètre. C'est fonction sont détaillée dans le fichier \emph{imu\_devs.c}.
	
	\subsubsection*{InitAccAndMag(void)}
	C'est la fonction qui est appelée pendant l'initialisation du programme et qui permet de configurer correctement les différents capteurs utilisés plus tard dans le programme.\\
	Les paramètres peuvent allez du mode d'alimentation à l'échelle utilisée tout en passant par la configuration du filtrage des signaux des capteurs.
	
	\subsubsection*{ReadAccelerometer(float* pfData) \& ReadMagnetometer(float* pfData)}
	Ce sont deux fonctions permettent de récupérer les informations des capteurs et de les stocker dans un pointeur mis en paramètre. Ces fonctions permettent aussi la calibration des données en fonction du mode choisi à l'initialisation.
	
	\paragraph{}
	Concernant le gyrozscope, le principe est exactement le même avec les fonctions \emph{InitGyro(void)} et \emph{ReadGyro(float* pfData)}.

  \subsection{Traitements des données}
	
	\paragraph{}
	Une fois les données récupérées depuis les capteurs il faut les traiter afin de calculer ce que nous cherchons: l'orientation de la centrale inertielle grâce à ses angles de roulis, de tangage et de lacet; ainsi que sa position relative par rapport au référentiel terrestre.
	
	\subsubsection*{ReadOrientation(float *pHeading, float *pRoll, float *pPitch)} 
	C'est la fonction qui permet de retourner dans les pointeurs en paramètres les angles d'orientation en effectuant les calculs détaillés dans la partie théorique :
	
	\begin{figure}[h]
	\centering
		\includegraphics[scale=0.7]{readOrientation}
	\caption{Fonction void ReadOrientation(float *pHeading, float *pRoll, float *pPitch)}
	\end{figure}
	
	L'utilisation d'un filtrage passe bas sur les données permet de lisser celles-ci les unes par rapports aux autres afin d'endiguer toute erreur de mesure du capteur.
	
	\paragraph{}
	Les calculs des angles de roulis et de tangage fonctionne très bien et donnent des résultats fiables et utilisables. Le problème vient du calcul de l'angle de lacet qui n'est précis qu'à l'horizontal. Une fois la carte dans une orientation quelconque, la valeur calculée de l'angle n'est plus correcte et la donnée ne peut plus être utilisée ensuite, l'erreur se répercutant dans les couches supérieures de l'algorithme.
	
	\newpage
	
	\subsubsection*{EulerMethode(float *AccBuffer, float *PosBuffer, int delay)}
	C'est la fonction qui permet de retourner le vecteur position de la carte en fonction du vecteur accélération en utilisant la méthode d'Euler. Pour ce faire il faut aussi mettre en paramètre le temps de délais entre deux mesures et faire l'hypothèse que les conditions initiales au début de la mesure sont nulles (vitesse et position).
	
	\begin{figure}[h]
	\centering
		\includegraphics[scale=0.7]{eulerMethode.png}
	\caption{Fonction void EulerMethode(float *AccBuffer, float *PosBuffer, int delay)}
	\end{figure}
	
	Cette fonction n'a pas été testée.
	
	\subsubsection*{SimpsonMethode}
	C'est la fonction qui permet de retourner dans les pointeurs en paramètre les positions relatives de la carte en utilisant la méthode de Simpson.\\
	Cette méthode n'a pas été implémentée.
	
	\subsubsection*{Basechangement(float *posBoard, float *posAbsolute, float roll, float pitch, float yaw)}
	Cette fonction permet d'effectuer le changement de repère du vecteur position de la carte et ainsi calculer la position de la carte dans le repère absolu connaissant son déplacement dans son repère propre et les angles de roulis, tangage et lacet de la carte.
	
	\begin{figure}[h]
	\centering
		\includegraphics[scale=0.7]{baseChangement.png}
	\caption{Fonction void Basechangement(float *posBoard, float *posAbsolute, float roll, float pitch, float yaw)}
	\end{figure}
	
	\subsection{Communication série}
	Une fois toutes les données calculées, il faut les afficher à l'utilisateur. La carte ne disposant d'aucun affichage intégré, mis à part ses LED - ce qui rend l'affichage pas vraiment évident - il faut communiquer ces données à un autre appareil - comme un PC - qui pourra les afficher.
	
	\paragraph{}
	Avant de parler d'une quelconque interface Homme-Machine, il est donc important de transmettre correctement ces données via une liaison série de type Virtual COM entre le port USB-USER de la carte et un port USB d'un ordinateur.\\
	La librairie permettant d'envoyer et de recevoir des message à travers une liaison série est aussi une librairie créée et mise à disposition par \textsc{STMicroelectronics} dans son projet de démonstration. \\
	
	\paragraph{}
	En connectant le port USB-USER de la carte à un PC, ce dernier doit installer le bon périphérique et ainsi reconnaître un port de communication VCP. Pour ce connecter à ce port, il faut que la liaison soit effective entre la carte et le PC, que la liaison soit initialisé du côté de la carte et que du côté du PC, on se connecte au port de communication alloué avec les bons paramètres, à savoir :
	\begin{itemize}
	\item BaudRate : 115200
	\item Bits de donnée : 8
	\item Parité : Non
	\item Bit de stop : 1
	\item Contrôle de flux : Non
	\end{itemize}
	
	\paragraph{} Une fois la connexion établie entre les deux entités, il est possible envoyer des messages à travers la liaison série grâce à la fonction \emph{VCP\_PutStr(char* buffer)} où le buffer est une chaine de caractères contenant le message que l'on souhaite envoyer.
	Dans notre cas, le protocole est le suivant : 
	\begin{equation}X: \%11.3f\qquad Y: \%11.3f\qquad Z: \%11.3f\backslash n\end{equation}
	
	où \emph{\%11.3f} est un nombre flottant avec 3 chiffres avant et après la virgule. 
	
	\paragraph{}
	Ce protocole permet l'affichage des informations directement dans un hyper terminal comme \emph{Termite} mais aussi la concaténation des informations par un autre logiciel connaissant ce protocole, comme c'est le cas pour l'interface utilisateur.
	
		\begin{figure}[h]
	\centering
		\includegraphics[scale=0.5]{termite.png}
	\caption{Hyper terminal affichant les valeurs des angles calculés par la carte}
	\end{figure}
	
	\section{Interface utilisateur}
	\paragraph{}
	L'interface utilisateur a été réalisée en \emph{C++} à l'aide du framework \emph{Qt} qui permet une utilisation multiplateforme et une grande liberté de programmation tout en ayant une communauté très active.
	
	\paragraph{}
	L'interface utilisateur permet la connexion à la liaison série initialisée par la carte. Cette connexion est soumise à différent paramètres défini par l'utilisateur lui même dans l'écran \emph{Settings}.
	
		\begin{figure}[h]
	\centering
		\includegraphics[scale=0.7]{settings.png}
	\caption{Écran \emph{Settings}}
	\end{figure}
	
	\paragraph{}
	Si les paramètres rentrés par l'utilisateur sont correct, il est alors possible de se connecter à la liaison série. Il faut toutefois que la liaison série ne soit pas déjà connectée à un autre programme, comme un hyper terminal, puisque la liaison série ne permet pas le multicast.\\
	Une fois connectée, l'interface récupère les messages envoyés par la carte sur la liaison série et concatène les données pour les réinjecter dans les éléments de l'interface graphique.
	
	\begin{figure}[h]
	\centering
		\includegraphics[scale=0.4]{IHM.png}
	\caption{Interface graphique}
	\end{figure}
	
	Les angles de roulis, tangage et lacet sont indiqués par les afficheurs LCD en haut de l'interface alors que la partie centrale permet quand à elle d'orienter un parallélépipède rectangle en fonction de l'orientation de la carte. Toute la partie 3D est réalisée à l'aide des librairies \emph{QtOpenGL} et \emph{QGLWidget}.
	
	\paragraph{}
	L'ensemble des codes sources est disponible sur un \emph{repository} \emph{GitHub} dont le lien est donné en \textsc{Annexe}.
	
\chapter{Reste à faire et améliorations}
	\section{Calcul de l'angle de lacet}
	\paragraph{}
	Il serait bien de réussir a corriger la mesure de l'angle de lacet. Cela peut se faire en intégrant les données du gyroscope pour retrouver la position angulaire autour de l'axe z.
	\paragraph{} Toutefois cette méthode n'est pas non plus parfaite puisqu'elle est amputée d'une erreur de \emph{dérive} que le gyroscope ne peut mesurer. Il faudrait alors mettre en abîme les deux méthodes de calcul afin que l'une compense l'erreur de l'autre et vice et versa.

	\section{Implémentation et comparaison de la méthode de Simpson}
	\paragraph{}
	La méthode de Simpson n'a pas été implémentée par soucis de temps. Il s'agirait ici de l'implémenter pour ensuite la comparée avec la méthode d'Euler pour prouver qu'elle est plus performante.\\
	Ceci dit, la méthode de Simpson nécessite la connaissance de 3 points de mesure pour faire l'approximation, ce qui double donc le temps de cycle de la méthode comparée à celle d'Euler. 
	
	\paragraph{}
	D'autres méthodes pourraient être aussi implémentées, comme le filtrage de Kalman ou le filtrage de Madgwick qui sont des méthodes notamment utilisées dans les centrales inertielles industrielles. Leur algorithme fait entrer en jeu des quaternions et malgré quelques lectures et revues de code sur ce sujet, il semblait très compliqué d'expliquer vraiment en quoi consistaient ces méthodes.
	
	\section{Communication Interface vers carte}
	\paragraph{}
	il pourrait être possible d'utiliser la liaison série dans le sens inverse. C'est-à-dire au lieu de faire du Broadcast pur et simple de l'information, l'interface utilisateur pourrait aussi écrire sur la liaison série et communiquer avec la carte pour, par exemple, lui demander d'utiliser une méthode plutôt qu'une autre ou modifier le temps de cycle des calculs. \\
	La librairie implémentée dans le projet permet cette amélioration, elle n'a juste pas été tentée.

		
\chapter*{Conclusion}
\addcontentsline{toc}{chapter}{Conclusion}
\paragraph{}
Le projet permet actuellement de pouvoir visualiser l'orientation de la carte \emph{STM32F3} grâce à ces accéléromètres sur une interface graphique qui récupère les données via une liaison série USB.
\paragraph{}
Cela amorce les prémisses d'une centrale inertielle, mais comme nous l'avons vu, beaucoup de chemin et d'améliorations restent encore à faire, principalement en matière d'algorithme.\\
La carte en elle même est capable de supporter la charge de travail d'une centrale inertielle complète, même si les temps de cycle sont parfois problématiques pour des méthodes trop peu précises.
	
	\appendix
	
	\chapter{Sources \& Bibliographie}
	
	\subsection*{Sources}
	\subsubsection*{Code Source du projet}
	https://github.com/Brozer13/STM32F3-Orientation
	\subsubsection*{Code de démonstration STM32F3}
	http://www.st.com/web/en/catalog/tools/PF258154
	\subsubsection*{Code source de la librairie VCOM}
	http://controlsoft.nmmu.ac.za/STM32F3-Discovery-Board/Example-programs/Virtual-COM-Port-(VCP)
	
	\subsection*{Bibliographie}
	\subsubsection*{Angles d'Euler}
	https://www.wikiwand.com/en/Euler\_angles
	\subsubsection*{Tilt Sensing Using a Three-Axis Accelerometer}
	\emph{par Mark Pedley}\\
	http://www.freescale.com/files/sensors/doc/app\_note/AN3461.pdf
	\subsubsection*{Méthode d'Euler}
	https://www.wikiwand.com/en/Euler\_method
	\subsubsection*{Méthode de Simpson}
	http://www.wikiwand.com/en/Simpson\%27s\_rule
	\subsubsection*{Introduction au filtre de Kalman}
	\emph{par D. Alazard, cours de l'école \textsc{supaero}}\\
	http://oatao.univ-toulouse.fr/2248/1/Alazard\_2248.pdf
	
	
\end{document}